import { jsPDF } from 'jspdf';
import { registerCyrillicFont, safeText } from './cyrillicFonts';

export const generatePdf = async (parsedData, options) => {
  try {
    const doc = new jsPDF();
    let yPosition = 20;
    const margin = 20;
    const lineHeight = options.fontSize * options.lineHeight;
    const fixedTextOffset = options.fixedTextOffset || 80;

    // Регистрируем кириллические шрифты
    await registerCyrillicFont(doc);

    doc.setFontSize(options.fontSize);
    doc.setFont(options.fontFamily, options.fontStyle);

    // Заголовок
    if (options.showTitle) {
      const titleSize = Math.max(options.fontSize + 4, 14);
      doc.setFontSize(titleSize);
      doc.setFont(options.fontFamily, 'bold');
      const title = parsedData.title || 'Song';
      safeText(doc, title, 105, yPosition, { align: 'center' });
      yPosition += titleSize * options.lineHeight + 2;
      doc.setFontSize(options.fontSize);
    }

    // Метаданные
    if (options.showTempo) {
      doc.setFont(options.fontFamily, 'normal');
      const metaInfo = [
        parsedData.tempo && `T: ${parsedData.tempo}`,
        parsedData.meter && `M: ${parsedData.meter}`,
        parsedData.key && `K: ${parsedData.key}`,
        parsedData.composer && `By: ${parsedData.composer}`
      ].filter(Boolean).join(' | ');

      safeText(doc, metaInfo, 105, yPosition, { align: 'center' });
      yPosition += lineHeight;
    }

    yPosition += 4;

    // Секции
    if (parsedData.sections && parsedData.sections.length > 0) {
      for (const section of parsedData.sections) {
        // Заголовок секции
        const sectionSize = options.fontSize + 1;
        doc.setFontSize(sectionSize);
        doc.setFont(options.fontFamily, 'bold');
        const sectionName = section.name || 'Section';
        safeText(doc, sectionName, margin, yPosition);
        yPosition += sectionSize * options.lineHeight;
        doc.setFontSize(options.fontSize);
        doc.setFont(options.fontFamily, 'normal');

        if (section.measures && section.measures.length > 0) {
          for (const measure of section.measures) {
            // Отображаем аккорды
            if (options.showChords && measure.chordPart) {
              doc.setFont(options.fontFamily, 'bold');
              safeText(doc, measure.chordPart, margin, yPosition);
            }

            // Отображаем текст с выравниванием
            if (options.showLyrics && measure.lyrics) {
              doc.setFont(options.fontFamily, 'normal');
              safeText(doc, measure.lyrics, fixedTextOffset, yPosition);
            }

            yPosition += lineHeight;

            if (yPosition > 270) {
              doc.addPage();
              yPosition = 20;
              doc.setFontSize(options.fontSize);
              doc.setFont(options.fontFamily, options.fontStyle);
            }
          }
        }

        yPosition += lineHeight / 2;
      }
    }

    // Легенда
    if (options.showLegend && yPosition < 270) {
      const legendSize = options.fontSize - 1;
      doc.setFontSize(legendSize);
      doc.setFont(options.fontFamily, 'italic');
      doc.setTextColor(100, 100, 100);

      const legend = [
        options.capo > 0 && `Capo: fret ${options.capo}`,
        `Instrument: ${options.instrument}`,
        `Font: ${options.fontFamily} ${options.fontStyle}`,
        'Generated by Music Converter'
      ].filter(Boolean);

      legend.forEach((line, index) => {
        if (yPosition + (index * legendSize * options.lineHeight) < 285) {
          safeText(doc, line, margin, yPosition + (index * legendSize * options.lineHeight));
        }
      });
    }

    return doc.output('blob');

  } catch (error) {
    console.error('PDF generation error:', error);
    throw new Error('Failed to generate PDF');
  }
};